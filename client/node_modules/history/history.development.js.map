{"version":3,"file":"history.development.js","sources":["../../packages/history/modules/index.js"],"sourcesContent":["const PopAction = 'POP';\nconst PushAction = 'PUSH';\nconst ReplaceAction = 'REPLACE';\n\nconst BeforeUnloadEventType = 'beforeunload';\nconst HashChangeEventType = 'hashchange';\nconst PopStateEventType = 'popstate';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// BROWSER\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Browser history stores the location in regular URLs. This is the\n * standard for most web apps, but it requires some configuration on\n * the server to ensure you serve the same app at multiple URLs.\n */\nexport function createBrowserHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname, search, hash } = window.location;\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HASH\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Hash history stores the location in window.location.hash. This makes\n * it ideal for situations where you don't want to send the location to\n * the server for some reason, either because you do cannot configure it\n * or the URL space is reserved for something else.\n */\nexport function createHashHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname = '/', search = '', hash = '' } = parsePath(\n      window.location.hash.substr(1)\n    );\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  // TODO: Is this still necessary? Which browsers do\n  // not trigger popstate when the hash changes?\n  window.addEventListener(HashChangeEventType, event => {\n    let [, nextLocation] = getIndexAndLocation();\n\n    // Ignore extraneous hashchange events.\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function getBaseHref() {\n    let base = document.querySelector('base');\n    let href = '';\n\n    if (base && base.getAttribute('href')) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MEMORY\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Memory history stores the current location in memory. It is designed\n * for use in stateful non-browser environments like headless tests (in\n * node.js) and React Native.\n */\nexport function createMemoryHistory({\n  initialEntries = ['/'],\n  initialIndex = 0\n} = {}) {\n  let entries = initialEntries.map(entry => {\n    let location = readOnly({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey(),\n      ...(typeof entry === 'string' ? parsePath(entry) : entry)\n    });\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: ${JSON.stringify(\n        entry\n      )})`\n    );\n\n    return location;\n  });\n  let index = clamp(initialIndex, 0, entries.length - 1);\n\n  let action = PopAction;\n  let location = entries[index];\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(n) {\n    let nextIndex = clamp(index + n, 0, entries.length - 1);\n    let nextAction = PopAction;\n    let nextLocation = entries[nextIndex];\n    function retry() {\n      go(n);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      return blockers.push(fn);\n    }\n  };\n\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault();\n  // Chrome (and legacy IE) requires returnValue to be set.\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  let handlers = [];\n\n  return {\n    get length() {\n      return handlers.length;\n    },\n    push(fn) {\n      handlers.push(fn);\n      return function() {\n        handlers = handlers.filter(handler => handler !== fn);\n      };\n    },\n    call(arg) {\n      handlers.forEach(fn => fn && fn(arg));\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random()\n    .toString(36)\n    .substr(2, 8);\n}\n\nexport function createPath({ pathname = '/', search = '', hash = '' }) {\n  return pathname + search + hash;\n}\n\nexport function parsePath(path) {\n  let pieces = {};\n\n  if (path) {\n    let hashIndex = path.indexOf('#');\n    if (hashIndex >= 0) {\n      pieces.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf('?');\n    if (searchIndex >= 0) {\n      pieces.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      pieces.pathname = path;\n    }\n  }\n\n  return pieces;\n}\n"],"names":["warning","cond","message","console","Error","e","promptBeforeUnload","event","createEvents","handlers","length","push","fn","handler","call","arg","createKey","Math","createPath","pathname","search","hash","parsePath","path","pieces","hashIndex","searchIndex","createBrowserHistory","getIndexAndLocation","window","state","globalHistory","obj","key","createHref","to","getNextLocation","location","applyTx","nextAction","action","index","listeners","retry","nextLocation","blockers","historyState","url","usr","idx","error","replace","go","n","document","blockedPopTx","nextIndex","history","back","forward","listen","block","unblock","createHashHistory","handlePop","base","href","getBaseHref","JSON","createMemoryHistory","allowTx","entries","lowerBound","initialEntries","initialIndex","entry"],"mappings":"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"}