{"version":3,"file":"history.production.min.js","sources":["../../packages/history/modules/index.js"],"sourcesContent":["const PopAction = 'POP';\nconst PushAction = 'PUSH';\nconst ReplaceAction = 'REPLACE';\n\nconst BeforeUnloadEventType = 'beforeunload';\nconst HashChangeEventType = 'hashchange';\nconst PopStateEventType = 'popstate';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// BROWSER\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Browser history stores the location in regular URLs. This is the\n * standard for most web apps, but it requires some configuration on\n * the server to ensure you serve the same app at multiple URLs.\n */\nexport function createBrowserHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname, search, hash } = window.location;\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HASH\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Hash history stores the location in window.location.hash. This makes\n * it ideal for situations where you don't want to send the location to\n * the server for some reason, either because you do cannot configure it\n * or the URL space is reserved for something else.\n */\nexport function createHashHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname = '/', search = '', hash = '' } = parsePath(\n      window.location.hash.substr(1)\n    );\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  // TODO: Is this still necessary? Which browsers do\n  // not trigger popstate when the hash changes?\n  window.addEventListener(HashChangeEventType, event => {\n    let [, nextLocation] = getIndexAndLocation();\n\n    // Ignore extraneous hashchange events.\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function getBaseHref() {\n    let base = document.querySelector('base');\n    let href = '';\n\n    if (base && base.getAttribute('href')) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MEMORY\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Memory history stores the current location in memory. It is designed\n * for use in stateful non-browser environments like headless tests (in\n * node.js) and React Native.\n */\nexport function createMemoryHistory({\n  initialEntries = ['/'],\n  initialIndex = 0\n} = {}) {\n  let entries = initialEntries.map(entry => {\n    let location = readOnly({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey(),\n      ...(typeof entry === 'string' ? parsePath(entry) : entry)\n    });\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: ${JSON.stringify(\n        entry\n      )})`\n    );\n\n    return location;\n  });\n  let index = clamp(initialIndex, 0, entries.length - 1);\n\n  let action = PopAction;\n  let location = entries[index];\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(n) {\n    let nextIndex = clamp(index + n, 0, entries.length - 1);\n    let nextAction = PopAction;\n    let nextLocation = entries[nextIndex];\n    function retry() {\n      go(n);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      return blockers.push(fn);\n    }\n  };\n\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault();\n  // Chrome (and legacy IE) requires returnValue to be set.\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  let handlers = [];\n\n  return {\n    get length() {\n      return handlers.length;\n    },\n    push(fn) {\n      handlers.push(fn);\n      return function() {\n        handlers = handlers.filter(handler => handler !== fn);\n      };\n    },\n    call(arg) {\n      handlers.forEach(fn => fn && fn(arg));\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random()\n    .toString(36)\n    .substr(2, 8);\n}\n\nexport function createPath({ pathname = '/', search = '', hash = '' }) {\n  return pathname + search + hash;\n}\n\nexport function parsePath(path) {\n  let pieces = {};\n\n  if (path) {\n    let hashIndex = path.indexOf('#');\n    if (hashIndex >= 0) {\n      pieces.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf('?');\n    if (searchIndex >= 0) {\n      pieces.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      pieces.pathname = path;\n    }\n  }\n\n  return pieces;\n}\n"],"names":["event","createEvents","length","handlers","handler","fn","forEach","arg","createKey","random","Math","pathname","hash","e","g","parsePath","path","pieces","hashIndex","searchIndex","location","idx","obj","createHref","to","z","b","getNextLocation","c","state","l","applyTx","nextAction","getIndexAndLocation","listeners","n","globalHistory","window","document","d","blockedPopTx","blockers","nextIndex","nextLocation","index","action","retry","go","Object","history","push","v","historyState","url","usr","key","error","replace","back","forward","listen","block","unblock","promptBeforeUnload","f","a","href","createPath","handlePop","m","allowTx","lowerBound","entries","initialEntries","initialIndex","entry","search","u"],"mappings":"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"}