<<<<<<< HEAD
'use strict';(function(h,f){"object"===typeof exports&&"undefined"!==typeof module?f(exports,require("react"),require("history")):"function"===typeof define&&define.amd?define(["exports","react","history"],f):(h=h||self,f(h.ReactRouter={},h.React,h.HistoryLibrary))})(this,function(h,f,F){function n(){n=Object.assign||function(a){for(var b=1;b<arguments.length;b++){var d=arguments[b],e;for(e in d)Object.prototype.hasOwnProperty.call(d,e)&&(a[e]=d[e])}return a};return n.apply(this,arguments)}function G(a,
b){return b={exports:{}},a(b,b.exports),b.exports}function H(a,b,d,e,g){for(var k in a)if(ja(a,k)){try{if("function"!==typeof a[k]){var T=Error((e||"React class")+": "+d+" type `"+k+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof a[k]+"`.");T.name="Invariant Violation";throw T;}var c=a[k](b,k,e,d,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ka){c=ka}!c||c instanceof Error||I((e||"React class")+": type specification of "+d+" `"+k+"` is invalid; the type checker function must return `null` or an `Error` but returned a "+
typeof c+". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");if(c instanceof Error&&!(c.message in J)){J[c.message]=!0;var f=g?g():"";I("Failed "+d+" type: "+c.message+(null!=f?f:""))}}}function w(){return null}function x(a,b){if(!a)throw Error(b);}function K(a){var b=a.children,d=a.initialEntries,e=a.initialIndex;a=a.timeout;var g=f.useRef(null);null==g.current&&(g.current=F.createMemoryHistory({initialEntries:d,
initialIndex:e}));return f.createElement(y,{children:b,history:g.current,timeout:a})}function L(a){var b=a.to,d=a.replace;d=void 0===d?!1:d;a=a.state;M()(b,{replace:d,state:a});return null}function N(){return V()}function O(){return null}function P(a){return a.element}function y(a){var b=a.children;b=void 0===b?null:b;var d=a.history;a=a.timeout;var e=void 0===a?2E3:a,g=f.useState(d.location);a=g[0];var k=g[1];e=la({timeoutMs:e});var c=e[0];e=e[1];g=f.useRef(!1);f.useContext(l)?x(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):
void 0;g.current||(g.current=!0,d.listen(function(a){var b=a.location;c(function(){k(b)})}));return f.createElement(l.Provider,{children:b,value:{history:d,location:a,pending:e}})}function Q(a){var b=a.basename;b=void 0===b?"":b;var d=a.caseSensitive;d=void 0===d?!1:d;a=z(a.children);return W(a,b,d)}function z(a){var b=[];f.Children.forEach(a,function(a){if(f.isValidElement(a)){var e=a.props,d=e.children,k=e.from,c=e.path;e=e.to;a.type===f.Fragment?b.push.apply(b,z(d)):(c=c||k||"/",e?a={path:c,redirectTo:e}:
(a={path:c,element:a},d=z(d),d.length&&(a.children=d)),b.push(a))}});return b}function R(){return f.useContext(l).location}function M(){var a=f.useContext(l),b=a.history,d=a.pending,e=f.useContext(m).pathname;null==b?x(!1,"navigation may be used only in the context of a <Router> component"):void 0;return f.useCallback(function(a,k){var g=void 0===k?{}:k;k=g.replace;g=g.state;"number"===typeof a?b.go(a):(a=A(a,e),b[k||d?"replace":"push"](a,g))},[b,d,e])}function V(){return f.useContext(m).outlet}function S(a){var b=
f.useContext(m).pathname;return f.useMemo(function(){return A(a,b)},[a,b])}function W(a,b,d){void 0===b&&(b="");void 0===d&&(d=!1);var e=f.useContext(m),g=e.params,k=e.pathname;e=e.route;if(X){var c=e&&e.path;X(k,!e||e.path.endsWith("*"),'You rendered descendant <Routes> (or called `useRoutes`) at "'+k+'" (under <Route path="'+(c+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="')+
(c+'"> to <Route path="'+c+'/*">.'))}b=b?v([k,b]):k;e=M();var U=R();c=f.useMemo(function(){return Y(a,U,b,d)},[a,U,b,d]);if(!c)return null;var h=c.find(function(a){return null!=a.route.redirectTo});return h?(c=h.params,k=A(h.route.redirectTo,k),h=k.pathname,/:\w+/.test(h)&&(k=n({},k,{pathname:Z(h,c)})),e(k,{replace:!0}),null):c.reduceRight(function(a,d){var e=d.pathname,p=d.route;return f.createElement(m.Provider,{children:p.element,value:{outlet:a,params:Object.freeze(n({},g,{},d.params)),pathname:v([b,
e]),route:p}})},null)}function Y(a,b,d,e){void 0===d&&(d="");void 0===e&&(e=!1);"string"===typeof b&&(b=F.parsePath(b));d=d.replace(/^\/+|\/+$/g,"");var g=b.pathname.slice(1);if(d)if(d===g)g="";else if(g.startsWith(d))g=g.slice(d.length).replace(/^\/+/,"");else return null;var c=aa(a);ma(c);a=function(a){a=c[a];var b=a[1];if(ba(a[0],!0,e)[0].test(g))return{v:b.map(function(a,d){d=b.slice(0,d+1);d=v(d.map(function(a){return a.path}));var c=ba(d,!1,e);d=c[1];c=g.match(c[0]);return{params:na(d,c.slice(2)),
pathname:"/"+c[1],route:a}})}};for(b=0;b<c.length;++b)if(d=a(b),"object"===typeof d)return d.v;return null}function aa(a,b,d,e,g){void 0===b&&(b=[]);void 0===d&&(d="");void 0===e&&(e=[]);void 0===g&&(g=[]);a.forEach(function(a,c){var k=v([d,a.path]),f=e.concat(a);c=g.concat(c);b.push([k,f,c]);a.children&&aa(a.children,b,k,f,c)});return b}function oa(a){a=a.split("/");var b=a.length;a.some(ca)&&(b+=pa);return a.filter(function(a){return!ca(a)}).reduce(function(a,b){return a+(qa.test(b)?ra:""===b?sa:
ta)},b)}function ma(a){var b=a.reduce(function(a,b){b=b[0];a[b]=oa(b);return a},{});a.sort(function(a,e){var d=a[2];a=b[a[0]];var c=e[2];e=b[e[0]];return a!==e?e-a:ua(d,c)})}function ua(a,b){return a.length===b.length&&a.slice(0,-1).every(function(a,e){return a===b[e]})?a[a.length-1]-b[b.length-1]:0}function ba(a,b,d){var e=[],c="^("+a.replace(/^\/+/,"").replace(/\*\//g,"").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,function(a,b){e.push(b);return"([^\\/]+)"})+")";
a.endsWith("*")?(a.endsWith("/*")&&(c+="\\/?"),e.push("*"),c+="(.*)"):b&&(c+="\\/?");b&&(c+="$");return[new RegExp(c,d?void 0:"i"),e]}function na(a,b){return a.reduce(function(a,e,c){a[e]=b[c];return a},{})}function da(a,b){var d=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(function(a){".."===a?1<d.length&&d.pop():"."!==a&&d.push(a)});return 1<d.length?v(d):"/"}function A(a,b){void 0===b&&(b="/");var d="string"===typeof a?F.parsePath(a):a;a=d.pathname;
var e=d.search;e=void 0===e?"":e;d=d.hash;d=void 0===d?"":d;return{pathname:a?a.startsWith("/")?da(a,"/"):da(a,b):b,search:e,hash:d}}function Z(a,b){void 0===b&&(b={});return a.replace(/:(\w+)/g,function(a,e){return b[e]||":"+e}).replace(/\*$/,function(a){return b[a]||a})}f=f&&f.hasOwnProperty("default")?f["default"]:f;var ea=G(function(a,b){(function(){function a(a){if("object"===typeof a&&null!==a){var b=a.$$typeof;switch(b){case k:switch(a=a.type,a){case p:case t:case h:case m:case l:case C:return a;
default:switch(a=a&&a.$$typeof,a){case r:case q:case D:case E:case B:return a;default:return b}}case f:return b}}}function e(b){return a(b)===t}Object.defineProperty(b,"__esModule",{value:!0});var c="function"===typeof Symbol&&Symbol.for,k=c?Symbol.for("react.element"):60103,f=c?Symbol.for("react.portal"):60106,h=c?Symbol.for("react.fragment"):60107,l=c?Symbol.for("react.strict_mode"):60108,m=c?Symbol.for("react.profiler"):60114,B=c?Symbol.for("react.provider"):60109,r=c?Symbol.for("react.context"):
60110,p=c?Symbol.for("react.async_mode"):60111,t=c?Symbol.for("react.concurrent_mode"):60111,q=c?Symbol.for("react.forward_ref"):60112,C=c?Symbol.for("react.suspense"):60113,va=c?Symbol.for("react.suspense_list"):60120,E=c?Symbol.for("react.memo"):60115,D=c?Symbol.for("react.lazy"):60116,wa=c?Symbol.for("react.fundamental"):60117,xa=c?Symbol.for("react.responder"):60118,u=c?Symbol.for("react.scope"):60119;c=function(){};var ya=function(a){for(var b=arguments.length,c=Array(1<b?b-1:0),e=1;e<b;e++)c[e-
1]=arguments[e];var d=0;b="Warning: "+a.replace(/%s/g,function(){return c[d++]});"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(Ga){}},za=c=function(a,b){if(void 0===b)throw Error("`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning message argument");if(!a){for(var c=arguments.length,e=Array(2<c?c-2:0),d=2;d<c;d++)e[d-2]=arguments[d];ya.apply(void 0,[b].concat(e))}},n=!1;b.typeOf=a;b.AsyncMode=p;b.ConcurrentMode=t;b.ContextConsumer=r;b.ContextProvider=
B;b.Element=k;b.ForwardRef=q;b.Fragment=h;b.Lazy=D;b.Memo=E;b.Portal=f;b.Profiler=m;b.StrictMode=l;b.Suspense=C;b.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===h||a===t||a===m||a===l||a===C||a===va||"object"===typeof a&&null!==a&&(a.$$typeof===D||a.$$typeof===E||a.$$typeof===B||a.$$typeof===r||a.$$typeof===q||a.$$typeof===wa||a.$$typeof===xa||a.$$typeof===u)};b.isAsyncMode=function(b){n||(n=!0,za(!1,"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API."));
return e(b)||a(b)===p};b.isConcurrentMode=e;b.isContextConsumer=function(b){return a(b)===r};b.isContextProvider=function(b){return a(b)===B};b.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===k};b.isForwardRef=function(b){return a(b)===q};b.isFragment=function(b){return a(b)===h};b.isLazy=function(b){return a(b)===D};b.isMemo=function(b){return a(b)===E};b.isPortal=function(b){return a(b)===f};b.isProfiler=function(b){return a(b)===m};b.isStrictMode=function(b){return a(b)===
l};b.isSuspense=function(b){return a(b)===C}})()});(function(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a["default"]:a})(ea);var fa=G(function(a){a.exports=ea}),ha=Object.getOwnPropertySymbols,Aa=Object.prototype.hasOwnProperty,Ba=Object.prototype.propertyIsEnumerable,Ca=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+String.fromCharCode(a)]=a;if("0123456789"!==
Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(e){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var e,g=1;g<arguments.length;g++){var k=Object(arguments[g]);for(var f in k)Aa.call(k,f)&&(c[f]=k[f]);
if(ha){e=ha(k);for(var h=0;h<e.length;h++)Ba.call(k,e[h])&&(c[e[h]]=k[e[h]])}}return c},I=function(){},J={},ja=Function.call.bind(Object.prototype.hasOwnProperty);I=function(a){a="Warning: "+a;"undefined"!==typeof console&&console.error(a);try{throw Error(a);}catch(b){}};H.resetWarningCache=function(){J={}};var Da=Function.call.bind(Object.prototype.hasOwnProperty),u=function(){};u=function(a){a="Warning: "+a;"undefined"!==typeof console&&console.error(a);try{throw Error(a);}catch(b){}};var Ea=function(a,
b){function c(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b}function e(a){this.message=a;this.stack=""}function g(a){function c(c,t,q,h,f,g,k){h=h||"<<anonymous>>";g=g||q;if("SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"!==k){if(b)throw c=Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"),c.name="Invariant Violation",c;"undefined"!==typeof console&&(k=h+":"+q,!d[k]&&
3>p&&(u("You are manually calling a React.PropTypes validation function for the `"+g+"` prop on `"+h+"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."),d[k]=!0,p++))}return null==t[q]?c?null===t[q]?new e("The "+f+" `"+g+"` is marked as required in `"+(h+"`, but its value is `null`.")):new e("The "+f+" `"+g+"` is marked as required in `"+
(h+"`, but its value is `undefined`.")):null:a(t,q,h,f,g)}var d={},p=0,h=c.bind(null,!1);h.isRequired=c.bind(null,!0);return h}function k(a){return g(function(b,c,d,p,f,g){b=b[c];return h(b)!==a?(b=l(b),new e("Invalid "+p+" `"+f+"` of type `"+(b+"` supplied to `"+d+"`, expected `")+(a+"`."))):null})}function f(b){switch(typeof b){case "number":case "string":case "undefined":return!0;case "boolean":return!b;case "object":if(Array.isArray(b))return b.every(f);if(null===b||a(b))return!0;var c=b&&(n&&
b[n]||b["@@iterator"]);var e="function"===typeof c?c:void 0;if(e)if(c=e.call(b),e!==b.entries)for(;!(b=c.next()).done;){if(!f(b.value))return!1}else for(;!(b=c.next()).done;){if((b=b.value)&&!f(b[1]))return!1}else return!1;return!0;default:return!1}}function h(a){var b=typeof a;return Array.isArray(a)?"array":a instanceof RegExp?"object":"symbol"===b||a&&("Symbol"===a["@@toStringTag"]||"function"===typeof Symbol&&a instanceof Symbol)?"symbol":b}function l(a){if("undefined"===typeof a||null===a)return""+
a;var b=h(a);if("object"===b){if(a instanceof Date)return"date";if(a instanceof RegExp)return"regexp"}return b}function m(a){a=l(a);switch(a){case "array":case "object":return"an "+a;case "boolean":case "date":case "regexp":return"a "+a;default:return a}}var n="function"===typeof Symbol&&Symbol.iterator,r={array:k("array"),bool:k("boolean"),func:k("function"),number:k("number"),object:k("object"),string:k("string"),symbol:k("symbol"),any:g(w),arrayOf:function(a){return g(function(b,c,d,f,g){if("function"!==
typeof a)return new e("Property `"+g+"` of component `"+d+"` has invalid PropType notation inside arrayOf.");b=b[c];if(!Array.isArray(b))return b=h(b),new e("Invalid "+f+" `"+g+"` of type `"+(b+"` supplied to `"+d+"`, expected an array."));for(c=0;c<b.length;c++){var k=a(b,c,d,f,g+"["+c+"]","SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");if(k instanceof Error)return k}return null})},element:function(){return g(function(b,c,d,f,g){b=b[c];return a(b)?null:(b=h(b),new e("Invalid "+f+" `"+g+"` of type `"+
(b+"` supplied to `"+d+"`, expected a single ReactElement.")))})}(),elementType:function(){return g(function(a,b,c,d,f){a=a[b];return fa.isValidElementType(a)?null:(a=h(a),new e("Invalid "+d+" `"+f+"` of type `"+(a+"` supplied to `"+c+"`, expected a single ReactElement type.")))})}(),instanceOf:function(a){return g(function(b,c,d,f,h){if(!(b[c]instanceof a)){var g=a.name||"<<anonymous>>";b=b[c];b=b.constructor&&b.constructor.name?b.constructor.name:"<<anonymous>>";return new e("Invalid "+f+" `"+h+
"` of type `"+(b+"` supplied to `"+d+"`, expected instance of `")+(g+"`."))}return null})},node:function(){return g(function(a,b,c,d,h){return f(a[b])?null:new e("Invalid "+d+" `"+h+"` supplied to `"+(c+"`, expected a ReactNode."))})}(),objectOf:function(a){return g(function(b,c,d,f,g){if("function"!==typeof a)return new e("Property `"+g+"` of component `"+d+"` has invalid PropType notation inside objectOf.");b=b[c];c=h(b);if("object"!==c)return new e("Invalid "+f+" `"+g+"` of type `"+(c+"` supplied to `"+
d+"`, expected an object."));for(var k in b)if(Da(b,k)&&(c=a(b,k,d,f,g+"."+k,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"),c instanceof Error))return c;return null})},oneOf:function(a){return Array.isArray(a)?g(function(b,d,f,g,h){b=b[d];for(d=0;d<a.length;d++)if(c(b,a[d]))return null;d=JSON.stringify(a,function(a,b){return"symbol"===l(b)?String(b):b});return new e("Invalid "+g+" `"+h+"` of value `"+String(b)+"` supplied to `"+(f+"`, expected one of "+d+"."))}):(1<arguments.length?u("Invalid arguments supplied to oneOf, expected an array, got "+
arguments.length+" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."):u("Invalid argument supplied to oneOf, expected an array."),w)},oneOfType:function(a){if(!Array.isArray(a))return u("Invalid argument supplied to oneOfType, expected an instance of array."),w;for(var b=0;b<a.length;b++){var c=a[b];if("function"!==typeof c)return u("Invalid argument supplied to oneOfType. Expected an array of check functions, but received "+m(c)+" at index "+b+"."),w}return g(function(b,
c,d,f,g){for(var h=0;h<a.length;h++)if(null==(0,a[h])(b,c,d,f,g,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"))return null;return new e("Invalid "+f+" `"+g+"` supplied to `"+(d+"`."))})},shape:function(a){return g(function(b,c,d,f,g){b=b[c];c=h(b);if("object"!==c)return new e("Invalid "+f+" `"+g+"` of type `"+c+"` supplied to `"+(d+"`, expected `object`."));for(var k in a)if(c=a[k])if(c=c(b,k,d,f,g+"."+k,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"))return c;return null})},exact:function(a){return g(function(b,
c,d,f,g){var k=b[c],l=h(k);if("object"!==l)return new e("Invalid "+f+" `"+g+"` of type `"+l+"` supplied to `"+(d+"`, expected `object`."));l=Ca({},b[c],a);for(var m in l){l=a[m];if(!l)return new e("Invalid "+f+" `"+g+"` key `"+m+"` supplied to `"+d+"`.\nBad object: "+JSON.stringify(b[c],null,"  ")+"\nValid keys: "+JSON.stringify(Object.keys(a),null,"  "));if(l=l(k,m,d,f,g+"."+m,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"))return l}return null})}};e.prototype=Error.prototype;r.checkPropTypes=H;
r.resetWarningCache=H.resetWarningCache;return r.PropTypes=r},c=G(function(a){a.exports=Ea(fa.isElement,!0)}),l=f.createContext();l.Consumer.displayName="Location.Consumer";l.Provider.displayName="Location.Provider";var m=f.createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});m.Consumer.displayName="Route.Consumer";m.Provider.displayName="Route.Provider";K.displayName="MemoryRouter";K.propTypes={children:c.node,timeout:c.number,initialEntries:c.arrayOf(c.oneOfType([c.string,
c.shape({pathname:c.string,search:c.string,hash:c.string,state:c.object,key:c.string})])),initialIndex:c.number};L.displayName="Navigate";L.propTypes={to:c.oneOfType([c.string,c.shape({pathname:c.string,search:c.string,hash:c.string})]).isRequired,replace:c.bool,state:c.object};N.displayName="Outlet";N.propTypes={};O.displayName="Redirect";O.propTypes={children:function(a,b,c){if(null!=a[b])return Error("A <Redirect> should not have child routes; they will never be rendered.")},from:c.string,to:c.oneOfType([c.string,
c.shape({pathname:c.string,search:c.string,hash:c.string})])};P.displayName="Route";P.propTypes={children:c.node,element:c.element,path:c.string};var Fa=function(a){return a()},la=f.useTransition||function(){return[Fa,!1]};y.displayName="Router";y.propTypes={children:c.node,history:c.shape({action:c.string,location:c.object,push:c.func,replace:c.func,go:c.func,listen:c.func,block:c.func}),timeout:c.number};Q.displayName="Routes";Q.propTypes={basename:c.string,caseSensitive:c.bool,children:c.node};
var ia={};var X=function(a,b,c){if(!b&&!ia[a]){ia[a]=!0;"undefined"!==typeof console&&console.warn(c);try{throw Error(c);}catch(e){}}};var qa=/^:\w+$/,ra=2,sa=1,ta=10,pa=-2,ca=function(a){return"*"===a},v=function(a){return a.join("/").replace(/\/\/+/g,"/")};h.MemoryRouter=K;h.Navigate=L;h.Outlet=N;h.Redirect=O;h.Route=P;h.Router=y;h.Routes=Q;h.createRoutesFromChildren=z;h.generatePath=Z;h.matchRoutes=Y;h.resolveLocation=A;h.useBlocker=function(a,b){void 0===b&&(b=!0);var c=f.useContext(l).history;
null==c?x(!1,"navigation blocking may be used only in the context of a <Router> component"):void 0;f.useEffect(function(){if(b){var d=c.block(function(b){var c=n({},b,{retry:function(){d();b.retry()}});a(c)});return d}},[c,b,a])};h.useHref=function(a){a=S(a);var b=f.useContext(l).history;null==b?x(!1,"href resolution may be used only in the context of a <Router> component"):void 0;return b.createHref(a)};h.useLocation=R;h.useMatch=function(a){var b=R();a=S(a);return b.pathname===a.pathname};h.useNavigate=
M;h.useOutlet=V;h.useParams=function(){return f.useContext(m).params};h.useResolvedLocation=S;h.useRoutes=W;Object.defineProperty(h,"__esModule",{value:!0})});
=======
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('history')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'history'], factory) :
  (global = global || self, factory(global.ReactRouter = {}, global.React, global.HistoryLibrary));
}(this, (function (exports, React, history) { 'use strict';

  function invariant(cond, message) {
    if (!cond) throw new Error(message);
  }

  function warning(cond, message) {
    if (!cond) {
      // eslint-disable-next-line no-console
      if (typeof console !== "undefined") console.warn(message);

      try {
        // Welcome to debugging React Router!
        //
        // This error is thrown as a convenience so you can more easily
        // find the source for a warning that appears in the console by
        // enabling "pause on exceptions" in your JavaScript debugger.
        throw new Error(message); // eslint-disable-next-line no-empty
      } catch (e) {}
    }
  }

  const alreadyWarned = {};

  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned[key]) {
      alreadyWarned[key] = true;
       warning(false, message) ;
    }
  } ///////////////////////////////////////////////////////////////////////////////
  // CONTEXT
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * A Navigator is a "location changer"; it's how you get to different locations.
   *
   * Every history instance conforms to the Navigator interface, but the
   * distinction is useful primarily when it comes to the low-level <Router> API
   * where both the location and a navigator must be provided separately in order
   * to avoid "tearing" that may occur in a suspense-enabled app if the action
   * and/or location were to be read directly from the history instance.
   */


  const NavigationContext = /*#__PURE__*/React.createContext(null);

  {
    NavigationContext.displayName = "Navigation";
  }

  const LocationContext = /*#__PURE__*/React.createContext(null);

  {
    LocationContext.displayName = "Location";
  }

  const RouteContext = /*#__PURE__*/React.createContext({
    outlet: null,
    matches: []
  });

  {
    RouteContext.displayName = "Route";
  } ///////////////////////////////////////////////////////////////////////////////
  // COMPONENTS
  ///////////////////////////////////////////////////////////////////////////////


  /**
   * A <Router> that stores all entries in memory.
   *
   * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
   */
  function MemoryRouter(_ref) {
    let {
      basename,
      children,
      initialEntries,
      initialIndex
    } = _ref;
    let historyRef = React.useRef();

    if (historyRef.current == null) {
      historyRef.current = history.createMemoryHistory({
        initialEntries,
        initialIndex
      });
    }

    let history$1 = historyRef.current;
    let [state, setState] = React.useState({
      action: history$1.action,
      location: history$1.location
    });
    React.useLayoutEffect(() => history$1.listen(setState), [history$1]);
    return /*#__PURE__*/React.createElement(Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history$1
    });
  }

  /**
   * Changes the current location.
   *
   * Note: This API is mostly useful in React.Component subclasses that are not
   * able to use hooks. In functional components, we recommend you use the
   * `useNavigate` hook instead.
   *
   * @see https://reactrouter.com/docs/en/v6/api#navigate
   */
  function Navigate(_ref2) {
    let {
      to,
      replace,
      state
    } = _ref2;
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component.")  : void 0;
     warning(!React.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.") ;
    let navigate = useNavigate();
    React.useEffect(() => {
      navigate(to, {
        replace,
        state
      });
    });
    return null;
  }

  /**
   * Renders the child route's element, if there is one.
   *
   * @see https://reactrouter.com/docs/en/v6/api#outlet
   */
  function Outlet(props) {
    return useOutlet(props.context);
  }

  /**
   * Declares an element that should be rendered at a certain URL path.
   *
   * @see https://reactrouter.com/docs/en/v6/api#route
   */
  function Route(_props) {
      invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.")  ;
  }

  /**
   * Provides location context for the rest of the app.
   *
   * Note: You usually won't render a <Router> directly. Instead, you'll render a
   * router that is more specific to your environment such as a <BrowserRouter>
   * in web browsers or a <StaticRouter> for server rendering.
   *
   * @see https://reactrouter.com/docs/en/v6/api#router
   */
  function Router(_ref3) {
    let {
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = history.Action.Pop,
      navigator,
      static: staticProp = false
    } = _ref3;
    !!useInRouterContext() ?  invariant(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.")  : void 0;
    let basename = normalizePathname(basenameProp);
    let navigationContext = React.useMemo(() => ({
      basename,
      navigator,
      static: staticProp
    }), [basename, navigator, staticProp]);

    if (typeof locationProp === "string") {
      locationProp = history.parsePath(locationProp);
    }

    let {
      pathname = "/",
      search = "",
      hash = "",
      state = null,
      key = "default"
    } = locationProp;
    let location = React.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);

      if (trailingPathname == null) {
        return null;
      }

      return {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      };
    }, [basename, pathname, search, hash, state, key]);
     warning(location != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.") ;

    if (location == null) {
      return null;
    }

    return /*#__PURE__*/React.createElement(NavigationContext.Provider, {
      value: navigationContext
    }, /*#__PURE__*/React.createElement(LocationContext.Provider, {
      children: children,
      value: {
        location,
        navigationType
      }
    }));
  }

  /**
   * A container for a nested tree of <Route> elements that renders the branch
   * that best matches the current location.
   *
   * @see https://reactrouter.com/docs/en/v6/api#routes
   */
  function Routes(_ref4) {
    let {
      children,
      location
    } = _ref4;
    return useRoutes(createRoutesFromChildren(children), location);
  } ///////////////////////////////////////////////////////////////////////////////
  // HOOKS
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * Returns the full href for the given "to" value. This is useful for building
   * custom links that are also accessible and preserve right-click behavior.
   *
   * @see https://reactrouter.com/docs/en/v6/api#usehref
   */

  function useHref(to) {
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component.")  : void 0;
    let {
      basename,
      navigator
    } = React.useContext(NavigationContext);
    let {
      hash,
      pathname,
      search
    } = useResolvedPath(to);
    let joinedPathname = pathname;

    if (basename !== "/") {
      let toPathname = getToPathname(to);
      let endsWithSlash = toPathname != null && toPathname.endsWith("/");
      joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
    }

    return navigator.createHref({
      pathname: joinedPathname,
      search,
      hash
    });
  }
  /**
   * Returns true if this component is a descendant of a <Router>.
   *
   * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
   */

  function useInRouterContext() {
    return React.useContext(LocationContext) != null;
  }
  /**
   * Returns the current location object, which represents the current URL in web
   * browsers.
   *
   * Note: If you're using this it may mean you're doing some of your own
   * "routing" in your app, and we'd like to know what your use case is. We may
   * be able to provide something higher-level to better suit your needs.
   *
   * @see https://reactrouter.com/docs/en/v6/api#uselocation
   */

  function useLocation() {
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component.")  : void 0;
    return React.useContext(LocationContext).location;
  }

  /**
   * Returns the current navigation action which describes how the router came to
   * the current location, either by a pop, push, or replace on the history stack.
   *
   * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
   */
  function useNavigationType() {
    return React.useContext(LocationContext).navigationType;
  }
  /**
   * Returns true if the URL for the given "to" value matches the current URL.
   * This is useful for components that need to know "active" state, e.g.
   * <NavLink>.
   *
   * @see https://reactrouter.com/docs/en/v6/api#usematch
   */

  function useMatch(pattern) {
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component.")  : void 0;
    let {
      pathname
    } = useLocation();
    return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
  }
  /**
   * The interface for the navigate() function returned from useNavigate().
   */

  /**
   * Returns an imperative method for changing the location. Used by <Link>s, but
   * may also be used by other elements to change the location.
   *
   * @see https://reactrouter.com/docs/en/v6/api#usenavigate
   */
  function useNavigate() {
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component.")  : void 0;
    let {
      basename,
      navigator
    } = React.useContext(NavigationContext);
    let {
      matches
    } = React.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
    let activeRef = React.useRef(false);
    React.useEffect(() => {
      activeRef.current = true;
    });
    let navigate = React.useCallback(function (to, options) {
      if (options === void 0) {
        options = {};
      }

       warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.") ;
      if (!activeRef.current) return;

      if (typeof to === "number") {
        navigator.go(to);
        return;
      }

      let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);

      if (basename !== "/") {
        path.pathname = joinPaths([basename, path.pathname]);
      }

      (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
    }, [basename, navigator, routePathnamesJson, locationPathname]);
    return navigate;
  }
  const OutletContext = /*#__PURE__*/React.createContext(null);
  /**
   * Returns the context (if provided) for the child route at this level of the route
   * hierarchy.
   * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
   */

  function useOutletContext() {
    return React.useContext(OutletContext);
  }
  /**
   * Returns the element for the child route at this level of the route
   * hierarchy. Used internally by <Outlet> to render child routes.
   *
   * @see https://reactrouter.com/docs/en/v6/api#useoutlet
   */

  function useOutlet(context) {
    let outlet = React.useContext(RouteContext).outlet;

    if (outlet) {
      return /*#__PURE__*/React.createElement(OutletContext.Provider, {
        value: context
      }, outlet);
    }

    return outlet;
  }
  /**
   * Returns an object of key/value pairs of the dynamic params from the current
   * URL that were matched by the route path.
   *
   * @see https://reactrouter.com/docs/en/v6/api#useparams
   */

  function useParams() {
    let {
      matches
    } = React.useContext(RouteContext);
    let routeMatch = matches[matches.length - 1];
    return routeMatch ? routeMatch.params : {};
  }
  /**
   * Resolves the pathname of the given `to` value against the current location.
   *
   * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
   */

  function useResolvedPath(to) {
    let {
      matches
    } = React.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
    return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
  }
  /**
   * Returns the element of the route that matched the current location, prepared
   * with the correct context to render the remainder of the route tree. Route
   * elements in the tree must render an <Outlet> to render their child route's
   * element.
   *
   * @see https://reactrouter.com/docs/en/v6/api#useroutes
   */

  function useRoutes(routes, locationArg) {
    !useInRouterContext() ?  invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component.")  : void 0;
    let {
      matches: parentMatches
    } = React.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;

    {
      // You won't get a warning about 2 different <Routes> under a <Route>
      // without a trailing *, but this is a best-effort warning anyway since we
      // cannot even give the warning unless they land at the parent route.
      //
      // Example:
      //
      // <Routes>
      //   {/* This route path MUST end with /* because otherwise
      //       it will never match /blog/post/123 */}
      //   <Route path="blog" element={<Blog />} />
      //   <Route path="blog/feed" element={<BlogFeed />} />
      // </Routes>
      //
      // function Blog() {
      //   return (
      //     <Routes>
      //       <Route path="post/:id" element={<Post />} />
      //     </Routes>
      //   );
      // }
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
    }

    let locationFromContext = useLocation();
    let location;

    if (locationArg) {
      var _parsedLocationArg$pa;

      let parsedLocationArg = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
      !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop."))  : void 0;
      location = parsedLocationArg;
    } else {
      location = locationFromContext;
    }

    let pathname = location.pathname || "/";
    let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
    let matches = matchRoutes(routes, {
      pathname: remainingPathname
    });

    {
       warning(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ") ;
       warning(matches == null || matches[matches.length - 1].route.element !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" does not have an element. " + "This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.") ;
    }

    return _renderMatches(matches && matches.map(match => Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: joinPaths([parentPathnameBase, match.pathname]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
    })), parentMatches);
  } ///////////////////////////////////////////////////////////////////////////////
  // UTILS
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * Creates a route config from a React "children" object, which is usually
   * either a `<Route>` element or an array of them. Used internally by
   * `<Routes>` to create a route config from its children.
   *
   * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
   */

  function createRoutesFromChildren(children) {
    let routes = [];
    React.Children.forEach(children, element => {
      if (! /*#__PURE__*/React.isValidElement(element)) {
        // Ignore non-elements. This allows people to more easily inline
        // conditionals in their route config.
        return;
      }

      if (element.type === React.Fragment) {
        // Transparently support React.Fragment and its children.
        routes.push.apply(routes, createRoutesFromChildren(element.props.children));
        return;
      }

      !(element.type === Route) ?  invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>")  : void 0;
      let route = {
        caseSensitive: element.props.caseSensitive,
        element: element.props.element,
        index: element.props.index,
        path: element.props.path
      };

      if (element.props.children) {
        route.children = createRoutesFromChildren(element.props.children);
      }

      routes.push(route);
    });
    return routes;
  }
  /**
   * The parameters that were parsed from the URL path.
   */

  /**
   * Returns a path with params interpolated.
   *
   * @see https://reactrouter.com/docs/en/v6/api#generatepath
   */
  function generatePath(path, params) {
    if (params === void 0) {
      params = {};
    }

    return path.replace(/:(\w+)/g, (_, key) => {
      !(params[key] != null) ?  invariant(false, "Missing \":" + key + "\" param")  : void 0;
      return params[key];
    }).replace(/\/*\*$/, _ => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
  }
  /**
   * A RouteMatch contains info about how a route matched a URL.
   */

  /**
   * Matches the given routes to a location and returns the match data.
   *
   * @see https://reactrouter.com/docs/en/v6/api#matchroutes
   */
  function matchRoutes(routes, locationArg, basename) {
    if (basename === void 0) {
      basename = "/";
    }

    let location = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location.pathname || "/", basename);

    if (pathname == null) {
      return null;
    }

    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;

    for (let i = 0; matches == null && i < branches.length; ++i) {
      matches = matchRouteBranch(branches[i], pathname);
    }

    return matches;
  }

  function flattenRoutes(routes, branches, parentsMeta, parentPath) {
    if (branches === void 0) {
      branches = [];
    }

    if (parentsMeta === void 0) {
      parentsMeta = [];
    }

    if (parentPath === void 0) {
      parentPath = "";
    }

    routes.forEach((route, index) => {
      let meta = {
        relativePath: route.path || "",
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index,
        route
      };

      if (meta.relativePath.startsWith("/")) {
        !meta.relativePath.startsWith(parentPath) ?  invariant(false, "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.")  : void 0;
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }

      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
      // route tree depth-first and child routes appear before their parents in
      // the "flattened" version.

      if (route.children && route.children.length > 0) {
        !(route.index !== true) ?  invariant(false, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."))  : void 0;
        flattenRoutes(route.children, branches, routesMeta, path);
      } // Routes without a path shouldn't ever match by themselves unless they are
      // index routes, so don't add them to the list of possible branches.


      if (route.path == null && !route.index) {
        return;
      }

      branches.push({
        path,
        score: computeScore(path, route.index),
        routesMeta
      });
    });
    return branches;
  }

  function rankRouteBranches(branches) {
    branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
    : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
  }

  const paramRe = /^:\w+$/;
  const dynamicSegmentValue = 3;
  const indexRouteValue = 2;
  const emptySegmentValue = 1;
  const staticSegmentValue = 10;
  const splatPenalty = -2;

  const isSplat = s => s === "*";

  function computeScore(path, index) {
    let segments = path.split("/");
    let initialScore = segments.length;

    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }

    if (index) {
      initialScore += indexRouteValue;
    }

    return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
  }

  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0;
  }

  function matchRouteBranch(branch, pathname) {
    let {
      routesMeta
    } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];

    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      let end = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end
      }, remainingPathname);
      if (!match) return null;
      Object.assign(matchedParams, match.params);
      let route = meta.route;
      matches.push({
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
        route
      });

      if (match.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
      }
    }

    return matches;
  }
  /**
   * Renders the result of `matchRoutes()` into a React element.
   */


  function renderMatches(matches) {
    return _renderMatches(matches);
  }

  function _renderMatches(matches, parentMatches) {
    if (parentMatches === void 0) {
      parentMatches = [];
    }

    if (matches == null) return null;
    return matches.reduceRight((outlet, match, index) => {
      return /*#__PURE__*/React.createElement(RouteContext.Provider, {
        children: match.route.element !== undefined ? match.route.element : /*#__PURE__*/React.createElement(Outlet, null),
        value: {
          outlet,
          matches: parentMatches.concat(matches.slice(0, index + 1))
        }
      });
    }, null);
  }
  /**
   * A PathPattern is used to match on some portion of a URL pathname.
   */


  /**
   * Performs pattern matching on a URL pathname and returns information about
   * the match.
   *
   * @see https://reactrouter.com/docs/en/v6/api#matchpath
   */
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = {
        path: pattern,
        caseSensitive: false,
        end: true
      };
    }

    let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
    let match = pathname.match(matcher);
    if (!match) return null;
    let matchedPathname = match[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match.slice(1);
    let params = paramNames.reduce((memo, paramName, index) => {
      // We need to compute the pathnameBase here using the raw splat value
      // instead of using params["*"] later because it will be decoded then
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }

      memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
      return memo;
    }, {});
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }

  function compilePath(path, caseSensitive, end) {
    if (caseSensitive === void 0) {
      caseSensitive = false;
    }

    if (end === void 0) {
      end = true;
    }

     warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\".")) ;
    let paramNames = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
    .replace(/^\/*/, "/") // Make sure it has a leading /
    .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
    .replace(/:(\w+)/g, (_, paramName) => {
      paramNames.push(paramName);
      return "([^\\/]+)";
    });

    if (path.endsWith("*")) {
      paramNames.push("*");
      regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
      : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
    } else {
      regexpSource += end ? "\\/*$" // When matching to the end, ignore trailing slashes
      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
      // parent routes to matching only their own words and nothing more, e.g. parent
      // route "/home" should not match "/home2".
      "(?:\\b|\\/|$)";
    }

    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
    return [matcher, paramNames];
  }

  function safelyDecodeURIComponent(value, paramName) {
    try {
      return decodeURIComponent(value);
    } catch (error) {
       warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ").")) ;
      return value;
    }
  }
  /**
   * Returns a resolved path object relative to the given pathname.
   *
   * @see https://reactrouter.com/docs/en/v6/api#resolvepath
   */


  function resolvePath(to, fromPathname) {
    if (fromPathname === void 0) {
      fromPathname = "/";
    }

    let {
      pathname: toPathname,
      search = "",
      hash = ""
    } = typeof to === "string" ? history.parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash)
    };
  }

  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach(segment => {
      if (segment === "..") {
        // Keep the root "" segment so the pathname starts at /
        if (segments.length > 1) segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }

  function resolveTo(toArg, routePathnames, locationPathname) {
    let to = typeof toArg === "string" ? history.parsePath(toArg) : toArg;
    let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the
    // route context. This is explained in `Note on `<Link to>` values` in our
    // migration guide from v5 as a means of disambiguation between `to` values
    // that begin with `/` and those that do not. However, this is problematic for
    // `to` values that do not provide a pathname. `to` can simply be a search or
    // hash string, in which case we should assume that the navigation is relative
    // to the current location's pathname and *not* the route pathname.

    let from;

    if (toPathname == null) {
      from = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;

      if (toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
        // URL segment".  This is a key difference from how <a href> works and a
        // major reason we call this a "to" value instead of a "href".

        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }

        to.pathname = toSegments.join("/");
      } // If there are more ".." segments than parent routes, resolve relative to
      // the root / URL.


      from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }

    let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.

    if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
      path.pathname += "/";
    }

    return path;
  }

  function getToPathname(to) {
    // Empty strings should be treated the same as / paths
    return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? history.parsePath(to).pathname : to.pathname;
  }

  function stripBasename(pathname, basename) {
    if (basename === "/") return pathname;

    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }

    let nextChar = pathname.charAt(basename.length);

    if (nextChar && nextChar !== "/") {
      // pathname does not start with basename/
      return null;
    }

    return pathname.slice(basename.length) || "/";
  }

  const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");

  const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

  const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;

  const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash; ///////////////////////////////////////////////////////////////////////////////

  exports.MemoryRouter = MemoryRouter;
  exports.Navigate = Navigate;
  exports.Outlet = Outlet;
  exports.Route = Route;
  exports.Router = Router;
  exports.Routes = Routes;
  exports.UNSAFE_LocationContext = LocationContext;
  exports.UNSAFE_NavigationContext = NavigationContext;
  exports.UNSAFE_RouteContext = RouteContext;
  exports.createRoutesFromChildren = createRoutesFromChildren;
  exports.generatePath = generatePath;
  exports.matchPath = matchPath;
  exports.matchRoutes = matchRoutes;
  exports.renderMatches = renderMatches;
  exports.resolvePath = resolvePath;
  exports.useHref = useHref;
  exports.useInRouterContext = useInRouterContext;
  exports.useLocation = useLocation;
  exports.useMatch = useMatch;
  exports.useNavigate = useNavigate;
  exports.useNavigationType = useNavigationType;
  exports.useOutlet = useOutlet;
  exports.useOutletContext = useOutletContext;
  exports.useParams = useParams;
  exports.useResolvedPath = useResolvedPath;
  exports.useRoutes = useRoutes;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
>>>>>>> b4ab17f20a00d9afc427fe962c56ae4f03680b0c
//# sourceMappingURL=react-router.development.js.map
