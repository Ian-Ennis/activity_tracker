{"version":3,"file":"react-router.production.min.js","sources":["../../../packages/react-router/index.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { createMemoryHistory, parsePath } from 'history';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\nconst LocationContext = React.createContext();\n\nif (__DEV__) {\n  LocationContext.Consumer.displayName = 'Location.Consumer';\n  LocationContext.Provider.displayName = 'Location.Provider';\n}\n\nconst RouteContext = React.createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: '',\n  route: null\n});\n\nif (__DEV__) {\n  RouteContext.Consumer.displayName = 'Route.Consumer';\n  RouteContext.Provider.displayName = 'Route.Provider';\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A <Router> that stores all entries in memory.\n */\nexport function MemoryRouter({\n  children,\n  initialEntries,\n  initialIndex,\n  timeout\n}) {\n  let historyRef = React.useRef(null);\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  return (\n    <Router\n      children={children}\n      history={historyRef.current}\n      timeout={timeout}\n    />\n  );\n}\n\nif (__DEV__) {\n  MemoryRouter.displayName = 'MemoryRouter';\n  MemoryRouter.propTypes = {\n    children: PropTypes.node,\n    timeout: PropTypes.number,\n    initialEntries: PropTypes.arrayOf(\n      PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.shape({\n          pathname: PropTypes.string,\n          search: PropTypes.string,\n          hash: PropTypes.string,\n          state: PropTypes.object,\n          key: PropTypes.string\n        })\n      ])\n    ),\n    initialIndex: PropTypes.number\n  };\n}\n\n/**\n * Navigate programmatically using a component.\n */\nexport function Navigate({ to, replace = false, state }) {\n  let navigate = useNavigate();\n  navigate(to, { replace, state });\n  return null;\n}\n\nif (__DEV__) {\n  Navigate.displayName = 'Navigate';\n  Navigate.propTypes = {\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ]).isRequired,\n    replace: PropTypes.bool,\n    state: PropTypes.object\n  };\n}\n\n/**\n * Renders the child route's element, if there is one.\n */\nexport function Outlet() {\n  return useOutlet();\n}\n\nif (__DEV__) {\n  Outlet.displayName = 'Outlet';\n  Outlet.propTypes = {};\n}\n\n/**\n * Used in a route config to redirect from one location to another.\n */\nexport function Redirect() {\n  return null;\n}\n\nif (__DEV__) {\n  Redirect.displayName = 'Redirect';\n\n  function redirectChildrenType(props, propName, componentName) {\n    if (props[propName] != null) {\n      return new Error(\n        'A <Redirect> should not have child routes; they will never be rendered.'\n      );\n    }\n  }\n\n  Redirect.propTypes = {\n    children: redirectChildrenType,\n    from: PropTypes.string,\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ])\n  };\n}\n\n/**\n * Used in a route config to render an element.\n */\nexport function Route({ element }) {\n  return element;\n}\n\nif (__DEV__) {\n  Route.displayName = 'Route';\n  Route.propTypes = {\n    children: PropTypes.node,\n    element: PropTypes.element,\n    path: PropTypes.string\n  };\n}\n\n// TODO: Remove once React.useTransition is stable.\nconst startTransition = tx => tx();\nconst useTransition = React.useTransition || (() => [startTransition, false]);\n\n/**\n * The root context provider. There should be only one of these in a given app.\n */\nexport function Router({ children = null, history, timeout = 2000 }) {\n  let [location, setLocation] = React.useState(history.location);\n  let [startTransition, pending] = useTransition({ timeoutMs: timeout });\n  let listeningRef = React.useRef(false);\n\n  invariant(\n    !React.useContext(LocationContext),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You never need more than one.`\n  );\n\n  if (!listeningRef.current) {\n    listeningRef.current = true;\n    history.listen(({ location }) => {\n      startTransition(() => {\n        setLocation(location);\n      });\n    });\n  }\n\n  return (\n    <LocationContext.Provider\n      children={children}\n      value={{ history, location, pending }}\n    />\n  );\n}\n\nif (__DEV__) {\n  Router.displayName = 'Router';\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.shape({\n      action: PropTypes.string,\n      location: PropTypes.object,\n      push: PropTypes.func,\n      replace: PropTypes.func,\n      go: PropTypes.func,\n      listen: PropTypes.func,\n      block: PropTypes.func\n    }),\n    timeout: PropTypes.number\n  };\n}\n\n/**\n * A wrapper for useRoutes that treats its children as route and/or redirect\n * objects.\n */\nexport function Routes({ basename = '', caseSensitive = false, children }) {\n  let routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n}\n\nif (__DEV__) {\n  Routes.displayName = 'Routes';\n  Routes.propTypes = {\n    basename: PropTypes.string,\n    caseSensitive: PropTypes.bool,\n    children: PropTypes.node\n  };\n}\n\n/**\n * Utility function that creates a routes config object from a React\n * \"children\" object, which is usually either a React element or an\n * array of elements.\n */\nexport function createRoutesFromChildren(children) {\n  let routes = [];\n\n  React.Children.forEach(children, element => {\n    // Ignore non-elements. This allows people to more\n    // easily inline conditionals in their route config.\n    if (!React.isValidElement(element)) return;\n\n    let { children, from, path, to } = element.props;\n\n    // Transparently support React.Fragment and its children.\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(children));\n      return;\n    }\n\n    path = path || from || '/';\n\n    // Components that have a to prop are redirects.\n    // All others should use path + element (and maybe children) props.\n    let route;\n    if (to) {\n      route = { path, redirectTo: to };\n    } else {\n      route = { path, element };\n\n      let childRoutes = createRoutesFromChildren(children);\n      if (childRoutes.length) {\n        route.children = childRoutes;\n      }\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n */\nexport function useBlocker(blocker, when = true) {\n  let { history } = React.useContext(LocationContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'navigation blocking may be used only in the context of a <Router> component'\n  );\n\n  React.useEffect(() => {\n    if (when) {\n      let unblock = history.block(tx => {\n        let autoUnblockingTx = {\n          ...tx,\n          retry() {\n            // Automatically unblock the transition so it can\n            // play all the way through before retrying it.\n            // TODO: Figure out how to re-enable this block if the\n            // transition is cancelled for some reason.\n            unblock();\n            tx.retry();\n          }\n        };\n\n        blocker(autoUnblockingTx);\n      });\n\n      return unblock;\n    }\n  }, [history, when, blocker]);\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n */\nexport function useHref(to) {\n  let resolvedLocation = useResolvedLocation(to);\n  let { history } = React.useContext(LocationContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'href resolution may be used only in the context of a <Router> component'\n  );\n\n  return history.createHref(resolvedLocation);\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * NOTE: If you're using this it may mean you're doing some of your own \"routing\"\n * in your app, and we'd like to know what your use case is. We may be able to\n * provide something higher-level to better suit your needs.\n */\nexport function useLocation() {\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n */\nexport function useMatch(to) {\n  let location = useLocation();\n  let resolvedLocation = useResolvedLocation(to);\n  // TODO: Try to match search + hash as well\n  return location.pathname === resolvedLocation.pathname;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n */\nexport function useNavigate() {\n  let { history, pending } = React.useContext(LocationContext);\n  let { pathname } = React.useContext(RouteContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'navigation may be used only in the context of a <Router> component'\n  );\n\n  let navigate = React.useCallback(\n    (to, { replace, state } = {}) => {\n      if (typeof to === 'number') {\n        history.go(to);\n      } else {\n        let relativeTo = resolveLocation(to, pathname);\n\n        // If we are pending transition, use REPLACE instead of PUSH.\n        // This will prevent URLs that we started navigating to but\n        // never fully loaded from appearing in the history stack.\n        let method = !!replace || pending ? 'replace' : 'push';\n        history[method](relativeTo, state);\n      }\n    },\n    [history, pending, pathname]\n  );\n\n  return navigate;\n}\n\n/**\n * Returns the outlet element at this level of the route hierarchy. Used to\n * render child routes.\n */\nexport function useOutlet() {\n  return React.useContext(RouteContext).outlet;\n}\n\n/**\n * Returns a hash of the dynamic params that were matched in the route path.\n * This is useful for using ids embedded in the URL to fetch data, but we\n * eventually want to provide something at a higher level for this.\n */\nexport function useParams() {\n  return React.useContext(RouteContext).params;\n}\n\n/**\n * Returns a fully-resolved location object relative to the current location.\n */\nexport function useResolvedLocation(to) {\n  let { pathname } = React.useContext(RouteContext);\n  return React.useMemo(() => resolveLocation(to, pathname), [to, pathname]);\n}\n\nlet missingTrailingSplatWarnings, warnAboutMissingTrailingSplatAt;\nif (__DEV__) {\n  missingTrailingSplatWarnings = {};\n  warnAboutMissingTrailingSplatAt = (pathname, cond, message) => {\n    if (!cond && !missingTrailingSplatWarnings[pathname]) {\n      missingTrailingSplatWarnings[pathname] = true;\n      warning(false, message);\n    }\n  };\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * Route objects may take one of 2 forms:\n *\n * - { path, element, children }\n * - { path, redirectTo }\n *\n * We should probably write this up in TypeScript instead of in a comment. In\n * fact, what am I even doing here. Nobody is ever going to read this.\n */\nexport function useRoutes(routes, basename = '', caseSensitive = false) {\n  let {\n    params: parentParams,\n    pathname: parentPathname,\n    route: parentRoute\n  } = React.useContext(RouteContext);\n\n  if (warnAboutMissingTrailingSplatAt) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since\n    // we cannot even give the warning unless they land at the parent route.\n    let parentPath = parentRoute && parentRoute.path;\n    warnAboutMissingTrailingSplatAt(\n      parentPathname,\n      !parentRoute || parentRoute.path.endsWith('*'),\n      `You rendered descendant <Routes> (or called \\`useRoutes\\`) at \"${parentPathname}\"` +\n        ` (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\".` +\n        ` This means if you navigate deeper, the parent won't match anymore and therefore` +\n        ` the child routes will never render.` +\n        `\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath}/*\">.`\n    );\n  }\n\n  basename = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n\n  let navigate = useNavigate();\n  let location = useLocation();\n  let matches = React.useMemo(\n    () => matchRoutes(routes, location, basename, caseSensitive),\n    [routes, location, basename, caseSensitive]\n  );\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  }\n\n  // If we matched a redirect, navigate and return null.\n  let redirectMatch = matches.find(match => isRedirectRoute(match.route));\n  if (redirectMatch) {\n    let { params, route } = redirectMatch;\n    let relativeTo = resolveLocation(route.redirectTo, parentPathname);\n\n    let { pathname } = relativeTo;\n    if (/:\\w+/.test(pathname)) {\n      // Allow param interpolation into <Redirect to>, e.g.\n      // <Redirect from=\"users/:id\" to=\"profile/:id\">\n      relativeTo = { ...relativeTo, pathname: generatePath(pathname, params) };\n    }\n\n    navigate(relativeTo, { replace: true });\n\n    return null;\n  }\n\n  // TODO: Initiate preload sequence here.\n\n  // Otherwise render an element.\n  let element = matches.reduceRight((outlet, { params, pathname, route }) => {\n    return (\n      <RouteContext.Provider\n        children={route.element}\n        value={{\n          outlet,\n          params: readOnly({ ...parentParams, ...params }),\n          pathname: joinPaths([basename, pathname]),\n          route\n        }}\n      />\n    );\n  }, null);\n\n  return element;\n}\n\nfunction isRedirectRoute(route) {\n  return route.redirectTo != null;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Matches the given routes to a location and returns the match data.\n */\nexport function matchRoutes(\n  routes,\n  location,\n  basename = '',\n  caseSensitive = false\n) {\n  if (typeof location === 'string') {\n    location = parsePath(location);\n  }\n\n  // TODO: Validate location\n  // - it should have a pathname\n  let base = basename.replace(/^\\/+|\\/+$/g, '');\n  let target = location.pathname.slice(1);\n\n  if (base) {\n    if (base === target) {\n      target = '';\n    } else if (target.startsWith(base)) {\n      target = target.slice(base.length).replace(/^\\/+/, '');\n    } else {\n      return null;\n    }\n  }\n\n  let flattenedRoutes = flattenRoutes(routes);\n\n  // TODO: Validate the routes config\n  // - routes should all have paths and elements\n  // - redirects should have a redirectTo\n  // - redirects should not have children\n  // - warn about unreachable routes\n\n  rankFlattenedRoutes(flattenedRoutes);\n\n  for (let i = 0; i < flattenedRoutes.length; ++i) {\n    let [path, flatRoutes] = flattenedRoutes[i];\n\n    // TODO: Match on search, state too\n    let [matcher] = compilePath(path, /* end */ true, caseSensitive);\n\n    if (matcher.test(target)) {\n      return flatRoutes.map((route, index) => {\n        let routes = flatRoutes.slice(0, index + 1);\n        let path = joinPaths(routes.map(r => r.path));\n        let [matcher, keys] = compilePath(path, /* end */ false, caseSensitive);\n        let match = target.match(matcher);\n\n        return {\n          params: createParams(keys, match.slice(2)),\n          pathname: '/' + match[1],\n          route\n        };\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction flattenRoutes(\n  routes,\n  flattenedRoutes = [],\n  parentPath = '',\n  parentRoutes = [],\n  parentIndexes = []\n) {\n  routes.forEach((route, index) => {\n    let path = joinPaths([parentPath, route.path]);\n    let routes = parentRoutes.concat(route);\n    let indexes = parentIndexes.concat(index);\n\n    flattenedRoutes.push([path, routes, indexes]);\n\n    if (route.children) {\n      flattenRoutes(route.children, flattenedRoutes, path, routes, indexes);\n    }\n  });\n\n  return flattenedRoutes;\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === '*';\n\nfunction computeScore(path) {\n  let segments = path.split('/');\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments\n    .filter(s => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === ''\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction rankFlattenedRoutes(flattenedRoutes) {\n  let pathScores = flattenedRoutes.reduce((memo, [path]) => {\n    memo[path] = computeScore(path);\n    return memo;\n  }, {});\n\n  flattenedRoutes.sort((a, b) => {\n    let [aPath, , aIndexes] = a;\n    let aScore = pathScores[aPath];\n\n    let [bPath, , bIndexes] = b;\n    let bScore = pathScores[bPath];\n\n    return aScore !== bScore\n      ? bScore - aScore // Higher score first\n      : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nfunction compareIndexes(a, b) {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? a[a.length - 1] - b[b.length - 1] // Earlier siblings come first\n    : 0; // It doesn't make sense to rank non-siblings by index, so they sort equal\n}\n\nfunction compilePath(path, end, caseSensitive) {\n  let keys = [];\n  let pattern =\n    '^(' +\n    path\n      .replace(/^\\/+/, '') // Ignore leading /\n      .replace(/\\*\\//g, '') // Ignore */ (from paths nested under a *)\n      .replace(/\\/?\\*?$/, '') // Ignore trailing /*, we'll handle it below\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_, key) => {\n        keys.push(key);\n        return '([^\\\\/]+)';\n      }) +\n    ')';\n\n  if (path.endsWith('*')) {\n    if (path.endsWith('/*')) {\n      pattern += '\\\\/?'; // Don't include the / in params['*']\n    }\n    keys.push('*');\n    pattern += '(.*)';\n  } else if (end) {\n    pattern += '\\\\/?';\n  }\n\n  if (end) pattern += '$';\n\n  let flags = caseSensitive ? undefined : 'i';\n  let matcher = new RegExp(pattern, flags);\n\n  return [matcher, keys];\n}\n\nfunction createParams(keys, values) {\n  return keys.reduce((params, key, index) => {\n    // TODO: Use decodeURIComponent here to decode values?\n    params[key] = values[index];\n    return params;\n  }, {});\n}\n\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, '');\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, '/');\nconst joinPaths = paths => normalizeSlashes(paths.join('/'));\nconst splitPath = path => normalizeSlashes(path).split('/');\n\nfunction resolvePathname(toPathname, fromPathname) {\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\n  let relativeSegments = splitPath(toPathname);\n\n  relativeSegments.forEach(segment => {\n    if (segment === '..') {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== '.') {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? joinPaths(segments) : '/';\n}\n\n/**\n * Returns a fully resolve location object relative to the given pathname.\n */\nexport function resolveLocation(to, fromPathname = '/') {\n  let { pathname: toPathname, search = '', hash = '' } =\n    typeof to === 'string' ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith('/')\n      ? resolvePathname(toPathname, '/')\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return { pathname, search, hash };\n}\n\n/**\n * Creates a path with params interpolated.\n */\nexport function generatePath(pathname, params = {}) {\n  return pathname\n    .replace(/:(\\w+)/g, (_, key) => params[key] || `:${key}`)\n    .replace(/\\*$/, splat => params[splat] || splat);\n}\n"],"names":["invariant","cond","message","Router","history","timeout","React","setLocation","startTransition","useTransition","timeoutMs","LocationContext","listeningRef","location","children","value","pending","createRoutesFromChildren","routes","element","from","path","to","route","redirectTo","childRoutes","useLocation","useNavigate","pathname","RouteContext","relativeTo","resolveLocation","replace","state","useOutlet","useResolvedLocation","useRoutes","basename","caseSensitive","parentParams","parentPathname","warnAboutMissingTrailingSplatAt","parentPath","parentRoute","joinPaths","redirectMatch","matches","match","params","generatePath","navigate","outlet","matchRoutes","parsePath","target","base","flattenedRoutes","flattenRoutes","parentRoutes","parentIndexes","index","indexes","rankFlattenedRoutes","pathScores","memo","computeScore","initialScore","segments","isSplat","splatPenalty","s","score","segment","paramRe","dynamicSegmentValue","emptySegmentValue","staticSegmentValue","a","b","aIndexes","bIndexes","bScore","aScore","compareIndexes","n","i","flatRoutes","compilePath","r","createParams","end","keys","pattern","_","key","matcher","RegExp","undefined","values","resolvePathname","toPathname","fromPathname","search","hash","splat","obj","tx","paths","MemoryRouter","initialEntries","initialIndex","historyRef","createMemoryHistory","Navigate","Outlet","Redirect","Route","Routes","useBlocker","blocker","when","unblock","autoUnblockingTx","retry","useHref","resolvedLocation","useMatch","useParams"],"mappings":"yeAMAA,WAAmBC,EAAMC,OAClBD,EAAM,YAAgBC,GAmLtBC,cAA8D,8BAAjC,WAAMC,YAASC,yBAAU,QAC7BC,WAAeF,uBAA9BG,OACVC,KAA4BC,EAAc,CAAEC,UAAWL,wBACzCC,UAAa,gBAGZK,IADpBX,kBAOEY,WAAuB,EACvBR,UAAe,gBAAGS,gBACA,WACdN,EAAYM,0BAMfF,YACCG,SAAUA,EACVC,MAAO,CAAEX,QAAAA,EAASS,SAAAA,EAAUG,QAAAA,KA6C3BC,WAAkCH,OACnCI,EAAS,6BAEUJ,GAAU,SAAAK,MAG1Bb,iBAAqBa,IAHgB,MAKPA,QAA7BL,aAAUM,SAAMC,yBAGDf,WACnBY,aAAkBA,EAAQD,EAAyBH,KAIrDO,EAAOA,GAAQD,GAAQ,IAKnBE,EACFC,EAAQ,CAAEF,KAAAA,EAAMG,WAAYF,IAE5BC,EAAQ,CAAEF,KAAAA,EAAMF,QAAAA,IAEZM,EAAcR,EAAyBH,aAEzCS,WAAiBE,IAIrBP,OAAYK,UA2ETG,iCACmBf,YAmBnBgB,aAAuB,MACDrB,aAAiBK,GAAtCP,YAASY,YACTY,EAAatB,aAAiBuB,yBAMlCzB,GADFJ,qBAME,SAACsB,KAAgC,iBAAP,8CAEtBlB,KAAWkB,IAEPQ,EAAaC,EAAgBT,EAAIM,GAMrCxB,EADe4B,GAAWhB,EAAU,UAAY,QAChCc,EAAYG,MAGhC,CAAC7B,EAASY,EAASY,IAUhBM,iCACmBL,UAenBM,WAA6Bb,OAC5BM,EAAatB,aAAiBuB,8BACf,oBAAsBP,EAAIM,KAAW,CAACN,EAAIM,IA4B1DQ,WAAmBlB,EAAQmB,EAAeC,YAAfD,IAAAA,EAAW,aAAIC,IAAAA,GAAgB,SAK3DhC,aAAiBuB,GAHXU,WACEC,0BAIRC,EAAiC,KAI/BC,EAAaC,GAAeA,SAE9BH,GACCG,GAAeA,gBAA0B,KAC1C,gEAAkEH,2BACxCE,sNAIiBA,wBAAgCA,WAI/EL,EAAWA,EAAWO,EAAU,CAACJ,EAAgBH,IAAaG,IAE/Cb,QACXd,EAAWa,WACDpB,WACZ,oBAAkBY,EAAQL,EAAUwB,EAAUC,KAC9C,CAACpB,EAAQL,EAAUwB,EAAUC,qBAS3BO,EAAgBC,QAAa,SAAAC,gBAAyBA,gCAElDC,EAAkBH,SAGlBjB,GAFFE,EAAaC,EADOc,mBAC2BL,aAG/C,YAAYZ,KAGdE,OAAkBA,GAAYF,SAAUqB,EAAarB,EAAUoB,MAGjEE,EAASpB,EAAY,CAAEE,SAAS,IAEzB,MAMKc,eAAoB,SAACK,KAAwC,IAAtBvB,aAAUL,iCAE1DM,YACCf,SAAUS,UACVR,MAAO,CACLoC,OAAAA,EACAH,YAAsBT,eACtBX,SAAUgB,EAAU,CAACP,EAAUT,IAC/BL,MAAAA,OAIL,MAgBE6B,WACLlC,EACAL,EACAwB,EACAC,YADAD,IAAAA,EAAW,aACXC,IAAAA,GAAgB,wBAGdzB,EAAWwC,YAAUxC,MAKZwB,UAAiB,aAAc,QACtCiB,EAASzC,iBAAwB,MAEjC0C,KACEA,IAASD,EACXA,EAAS,YACAA,aAAkBC,eAC3BD,EAASA,QAAaC,kBAAqB,OAAQ,QAMnDC,EAmCNC,WACEvC,EACAsC,EACAd,EACAgB,EACAC,mBAHAH,IAAAA,EAAkB,aAClBd,IAAAA,EAAa,aACbgB,IAAAA,EAAe,aACfC,IAAAA,EAAgB,eAED,SAACpC,EAAOqC,OACjBvC,EAAOuB,EAAU,CAACF,EAAYnB,SAC9BL,EAASwC,SAAoBnC,KACnBoC,SAAqBC,UAEd,CAACvC,EAAMH,EAAQ2C,gBAGlCJ,EAAclC,WAAgBiC,EAAiBnC,EAAMH,EAAQ2C,QAlD3CJ,CAAcvC,OAqFtC4C,SAA6BN,OACvBO,EAAaP,UAAuB,SAACQ,cAAO3C,QAtBlD4C,SAAsB5C,OAEhB6C,GADAC,EAAW9C,QAAW,2BAER+C,KAChBF,GAAgBG,aAIR,SAAAC,UAAMF,EAAQE,cAEpB,SAACC,EAAOC,aAELC,OAAaD,GACVE,EACY,KAAZF,EACAG,EACAC,KACNV,GAMWD,CAAa5C,OAEzB,YAEkB,SAACwD,EAAGC,OACTC,EAAYF,OACbd,EADac,UAGZG,EAAYF,mBACbf,EADae,OAItBG,EAASC,EAKjBC,SAAwBN,EAAGC,qBAEVA,UAAYD,QAAQ,aAAa,SAACO,EAAGC,cAAYP,EAAEO,MAG9DR,EAAEA,SAAW,GAAKC,EAAEA,SAAW,GAC/B,EAVEK,CAAeJ,EAAUC,OA5FXxB,cAEX6B,OACIC,KAAc9B,EAAgB6B,UAGzBE,UAAkCjD,WAEjCgB,YACRgC,OAAe,SAAC/D,EAAOqC,GACxB1C,EAASoE,QAAiB,EAAG1B,EAAQ,SAEnB2B,IADX3C,EAAU1B,OAAW,SAAAsE,wBACyBlD,SAGlD,CACLU,OAAQyC,YAHEnC,qBAG6B,IACvC1B,SAAU,IAAMmB,EAAM,GACtBxB,MAAAA,QAhBC8D,EAAI,EAAGA,EAAI7B,WAA0B6B,0BAArCA,2BAuGXE,WAAqBlE,EAAMqE,EAAKpD,OAC1BqD,EAAO,GACPC,EACF,KACAvE,UACW,OAAQ,YACR,QAAS,YACT,UAAW,YACX,sBAAuB,gBACvB,WAAW,SAACwE,EAAGC,UACtBH,OAAUG,GACH,eAEX,sBAEgB,MACZzE,WAAc,QAChBuE,GAAW,QAEbD,OAAU,KACVC,GAAW,QACFF,IACTE,GAAW,YAGJA,GAAW,KAKb,CAFOG,IAAIC,OAAOJ,EADbtD,OAAgB2D,EAAY,KAGvBN,GAGnBF,WAAsBE,EAAMO,oBACP,SAAClD,EAAQ8C,EAAKlC,UAE/BZ,EAAO8C,GAAOI,EAAOtC,OAEpB,IAQLuC,WAAyBC,EAAYC,OAC/BlC,EAAyCkC,UANE,OAAQ,YACX,SAAU,WAED,sBAFT,SAAU,WAED,cAM5B,SAAA7B,GACP,OAAZA,EAEoB,EAAlBL,UAAqBA,QACJ,MAAZK,GACTL,OAAcK,QAIXL,SAAsBvB,EAAUuB,GAAY,IAM9CpC,WAAyBT,EAAI+E,YAAAA,IAAAA,EAAe,WAEjC,mBAAWhD,YAAU/B,GAAMA,kDADN,2BAAW,KASzC,CAAEM,SANMwE,EACXA,aAAsB,KACpBD,EAAgBC,EAAY,KAC5BD,EAAgBC,EAAYC,GAC9BA,EAEeC,OAAAA,EAAQC,KAAAA,GAMtBtD,WAAsBrB,EAAUoB,mBAAAA,IAAAA,EAAS,cAEnC,WAAW,SAAC6C,EAAGC,YAAeA,QAAYA,aAC1C,OAAO,SAAAU,YAAgBA,IAAUA,SA9UZ/D,EA5Z5B9B,iEAOAkB,EAAevB,gBAAoB,CACvC6C,OAAQ,KACRH,OAAiByD,GACjB7E,SAAU,GACVL,MAAO,OA+IHf,EAAkBA,SAAAkG,eAClBjG,EAAgBH,iBAAwB,iBAAM,CAACE,GAAiB,IAmchEiE,EAAU,SACVC,EAAsB,EACtBC,EAAoB,EACpBC,EAAqB,GACrBP,KACAD,EAAUA,SAAAE,SAAW,MAANA,GA8Ff1B,EAAYA,SAAA+D,iBAAqC,aADT,SAAU,qBAtqBjDC,YAKJ,IAJD9F,aACA+F,mBACAC,iCAGIC,EAAazG,SAAa,mBAE1ByG,YACFA,UAAqBC,sBAAoB,CAAEH,eAAAA,EAAgBC,aAAAA,qBAI1D3G,GACCW,SAAUA,EACVV,QAAS2G,UACT1G,QAASA,gBA6BR4G,YAAkD,IAA9B3F,wDAEhBA,EAAI,CAAEU,QAAAA,EAASC,MAAAA,mBAuBnBiF,kCAYAC,gCAgCAC,kDAqEAC,YAAoE,8BAAvC,sDACrBpG,cACYoB,EAAUC,mGA+D9BgF,SAAoBC,EAASC,YAAAA,IAAAA,GAAO,OACnCpH,EAAYE,aAAiBK,iBAMjCP,GADFJ,mBAKgB,cACVwH,EAAM,KACJC,EAAUrH,SAAc,SAAAsG,OACtBgB,OACChB,GACHiB,iBAKEF,mBAKIC,kBAKX,CAACtH,EAASoH,EAAMD,eAOdK,SAAiBtG,GAClBuG,EAAmB1F,EAAoBb,OACrClB,EAAYE,aAAiBK,wBAMjCP,GADFJ,mBAK0B6H,+BAoBrBC,SAAkBxG,OACnBT,EAAWa,aACQS,EAAoBb,gBAEduG,sDAoDxBE,+BACmBlG"}